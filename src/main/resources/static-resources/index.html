<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akka Haiku</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Akka haiku</h1>
            <p>Submit text inputs to generate creative content</p>
        </div>

        <div class="qr-section">
            <h2>Scan QR Code to Submit Input</h2>
            <div class="qr-container" id="qrContainer">
                <div class="no-qr">
                    <span class="loading"></span> Loading QR code...
                </div>
            </div>
            <div class="qr-or-section">
                <span>OR</span>
            </div>
            <div class="direct-link-section">
                <a href="#" class="direct-link-btn" id="directLinkBtn">Use Direct Link Instead</a>
            </div>
        </div>

        <div class="input-section">
            <form class="input-form" id="inputForm">
                <input 
                    type="text" 
                    class="input-field" 
                    id="textInput" 
                    placeholder="Enter your creative text input..." 
                    required
                >
                <button type="submit" class="submit-btn" id="submitBtn">
                    Submit Input
                </button>
            </form>
            <div class="status" id="status"></div>
        </div>

        <div class="main-content">
            <!-- Removed Collected Inputs side pane -->
            <div class="content-section" style="width:100%;">
                <h2>Generated Content</h2>
                <div class="content-grid" id="contentGrid">
                    <div class="no-content">
                        No content generated yet. Submit some text inputs to get started!
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="connection-status" id="connectionStatus">
                <span class="loading"></span> Connecting to content stream...
            </div>
            <div class="connection-status" id="collectedConnectionStatus">
                <span class="loading"></span> Connecting to collected inputs stream...
            </div>
        </div>
    </div>

    <script>
        class QrCodeManager {
            constructor() {
                this.qrEventSource = null;
                this.qrContainer = document.getElementById('qrContainer');
                this.directLinkBtn = document.getElementById('directLinkBtn');
                this.currentQrCode = null;
                
                this.initializeQrStream();
                this.initializeDirectLink();
            }

            initializeQrStream() {
                try {
                    this.qrEventSource = new EventSource('/qrcodes');
                    
                    this.qrEventSource.onopen = () => {
                        console.log('QR code stream connected');
                    };

                    this.qrEventSource.onmessage = (event) => {
                        try {
                            const qrCode = JSON.parse(event.data);
                            this.handleQrCode(qrCode);
                        } catch (error) {
                            console.error('Error parsing QR code:', error);
                        }
                    };

                    this.qrEventSource.onerror = (error) => {
                        console.error('QR code EventSource error:', error);
                        this.showQrError();
                        
                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => {
                            if (this.qrEventSource.readyState === EventSource.CLOSED) {
                                this.initializeQrStream();
                            }
                        }, 5000);
                    };
                } catch (error) {
                    console.error('Failed to initialize QR code EventSource:', error);
                    this.showQrError();
                }
            }

            handleQrCode(qrCode) {
                this.currentQrCode = qrCode;
                
                this.qrContainer.innerHTML = `
                    <div class="qr-code-display">
                        <img src="${this.escapeHtml(qrCode.qrCodeUrl)}" alt="QR Code" class="qr-image" />
                        <p class="qr-info">Scan this QR code with your phone to submit input</p>
                        <p class="qr-id">Group ID: ${this.escapeHtml(qrCode.tokenGroupId)}</p>
                    </div>
                `;
                
                // Update direct link
                this.updateDirectLink(qrCode.tokenGroupId);
            }

            showQrError() {
                this.qrContainer.innerHTML = `
                    <div class="no-qr error">
                        ‚ùå Failed to load QR code - attempting to reconnect...
                    </div>
                `;
            }

            updateDirectLink(tokenGroupId) {
                this.directLinkBtn.href = `http://localhost:9000/gateway/${tokenGroupId}`;
            }

            initializeDirectLink() {
                this.directLinkBtn.addEventListener('click', (e) => {
                    if (!this.currentQrCode) {
                        e.preventDefault();
                        alert('QR code not loaded yet. Please wait...');
                    }
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            destroy() {
                if (this.qrEventSource) {
                    this.qrEventSource.close();
                }
            }
        }

        class InputsManager {
            constructor() {
                this.inputsList = document.getElementById('inputsList');
                this.pollingInterval = null;
                this.currentInputs = [];
                
                this.startPolling();
            }

            startPolling() {
                // Initial fetch
                this.fetchInputs();
                
                this.pollingInterval = setInterval(() => {
                    this.fetchInputs();
                }, 300);
            }

            async fetchInputs() {
                try {
                    const response = await fetch('http://localhost:9000/inputs');
                    
                    if (response.ok) {
                        const inputs = await response.json();
                        this.updateInputsList(inputs);
                    } else {
                        console.error('Failed to fetch inputs:', response.status, response.statusText);
                    }
                } catch (error) {
                    console.error('Error fetching inputs:', error);
                }
            }

            updateInputsList(inputs) {
                // Check if inputs have changed
                if (JSON.stringify(inputs) === JSON.stringify(this.currentInputs)) {
                    return; // No changes, skip update
                }
                
                this.currentInputs = inputs;
                
                // Clear existing content
                this.inputsList.innerHTML = '';
                
                if (inputs.length === 0) {
                    this.inputsList.innerHTML = `
                        <div class="no-inputs">
                            No inputs collected yet. Submit your first input above!
                        </div>
                    `;
                } else {
                    // Add inputs in reverse order (newest first)
                    inputs.slice().reverse().forEach((input, index) => {
                        const inputItem = document.createElement('div');
                        inputItem.className = 'input-item';
                        inputItem.innerHTML = `
                            <p class="input-text">${this.escapeHtml(input)}</p>
                        `;
                        
                        // Add entrance animation for new items
                        if (index < inputs.length - this.currentInputs.length + inputs.length) {
                            inputItem.style.opacity = '0';
                            inputItem.style.transform = 'translateX(-20px)';
                            
                            setTimeout(() => {
                                inputItem.style.transition = 'opacity 0.3s, transform 0.3s';
                                inputItem.style.opacity = '1';
                                inputItem.style.transform = 'translateX(0)';
                            }, index * 50);
                        }
                        
                        this.inputsList.appendChild(inputItem);
                    });
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            destroy() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
            }
        }

        class ContentGenerator {
            constructor() {
                this.contentEventSource = null;
                this.collectedEventSource = null;
                this.contentGrid = document.getElementById('contentGrid');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.collectedConnectionStatus = document.getElementById('collectedConnectionStatus');
                this.inputForm = document.getElementById('inputForm');
                this.textInput = document.getElementById('textInput');
                this.submitBtn = document.getElementById('submitBtn');
                this.status = document.getElementById('status');
                
                // Track collected inputs and generated content by inputId
                this.collectedInputsMap = new Map();
                this.generatedContentMap = new Map();
                
                this.initializeEventSources();
                this.initializeForm();
            }

            initializeEventSources() {
                this.initializeContentStream();
                this.initializeCollectedInputsStream();
            }

            initializeContentStream() {
                try {
                    this.contentEventSource = new EventSource('http://localhost:9000/content-stream');
                    
                    this.contentEventSource.onopen = () => {
                        this.updateConnectionStatus(true, 'content');
                    };

                    this.contentEventSource.onmessage = (event) => {
                        try {
                            const content = JSON.parse(event.data);
                            this.handleGeneratedContent(content);
                        } catch (error) {
                            console.error('Error parsing content:', error);
                        }
                    };

                    this.contentEventSource.onerror = (error) => {
                        console.error('Content EventSource error:', error);
                        this.updateConnectionStatus(false, 'content');
                        
                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => {
                            if (this.contentEventSource.readyState === EventSource.CLOSED) {
                                this.initializeContentStream();
                            }
                        }, 5000);
                    };
                } catch (error) {
                    console.error('Failed to initialize content EventSource:', error);
                    this.updateConnectionStatus(false, 'content');
                }
            }

            initializeCollectedInputsStream() {
                try {
                    this.collectedEventSource = new EventSource('http://localhost:9000/collected-inputs-stream');
                    
                    this.collectedEventSource.onopen = () => {
                        this.updateConnectionStatus(true, 'collected');
                    };

                    this.collectedEventSource.onmessage = (event) => {
                        try {
                            const collectedInputs = JSON.parse(event.data);
                            this.handleCollectedInputs(collectedInputs);
                        } catch (error) {
                            console.error('Error parsing collected inputs:', error);
                        }
                    };

                    this.collectedEventSource.onerror = (error) => {
                        console.error('Collected inputs EventSource error:', error);
                        this.updateConnectionStatus(false, 'collected');
                        
                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => {
                            if (this.collectedEventSource.readyState === EventSource.CLOSED) {
                                this.initializeCollectedInputsStream();
                            }
                        }, 5000);
                    };
                } catch (error) {
                    console.error('Failed to initialize collected inputs EventSource:', error);
                    this.updateConnectionStatus(false, 'collected');
                }
            }

            updateConnectionStatus(connected, type) {
                const statusElement = type === 'content' ? this.connectionStatus : this.collectedConnectionStatus;
                const streamName = type === 'content' ? 'content stream' : 'collected inputs stream';
                
                statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
                statusElement.innerHTML = connected 
                    ? `‚úÖ Connected to ${streamName}` 
                    : `‚ùå Disconnected from ${streamName} - attempting to reconnect...`;
            }

            handleCollectedInputs(collectedInputs) {
                const { inputId } = collectedInputs;
                
                // Store the collected inputs
                this.collectedInputsMap.set(inputId, collectedInputs);
                
                // Check if we already have generated content for this inputId
                if (!this.generatedContentMap.has(inputId)) {
                    // Show collected inputs since no generated content exists yet
                    this.addCollectedInputsItem(collectedInputs);
                }
                // If generated content already exists, we don't show collected inputs
            }

            handleGeneratedContent(content) {
                const { inputId } = content;
                
                // Store the generated content
                this.generatedContentMap.set(inputId, content);
                
                // Remove any existing collected inputs item for this inputId
                this.removeCollectedInputsItem(inputId);
                
                // Add the generated content
                this.addContentItem(content);
            }

            addCollectedInputsItem(collectedInputs) {
                // Remove "no content" message if it exists
                const noContent = this.contentGrid.querySelector('.no-content');
                if (noContent) {
                    noContent.remove();
                }

                const collectedItem = document.createElement('div');
                collectedItem.className = 'collected-inputs-item processing';
                collectedItem.setAttribute('data-input-id', collectedInputs.inputId);
                
                const timestamp = new Date(collectedInputs.createdAt).toLocaleString();

                collectedItem.innerHTML = `
                    <div class="collected-meta">
                        <span class="content-timestamp">${timestamp}</span>
                        <span class="collection-id">ID: ${this.escapeHtml(collectedInputs.inputId)}</span>
                    </div>
                    
                    <div class="collected-inputs-list">
                        <h4>Collected Input:</h4>
                        <div class="collected-input-text">${this.escapeHtml(collectedInputs.input)}</div>
                    </div>
                `;

                // Add new content at the beginning
                this.contentGrid.insertBefore(collectedItem, this.contentGrid.firstChild);
                
                // Add entrance animation
                collectedItem.style.opacity = '0';
                collectedItem.style.transform = 'translateY(20px)';
                
                setTimeout(() => {
                    collectedItem.style.transition = 'opacity 0.5s, transform 0.5s';
                    collectedItem.style.opacity = '1';
                    collectedItem.style.transform = 'translateY(0)';
                }, 100);
            }

            removeCollectedInputsItem(inputId) {
                const existingItem = this.contentGrid.querySelector(`[data-input-id="${inputId}"]`);
                if (existingItem) {
                    existingItem.style.transition = 'opacity 0.3s, transform 0.3s';
                    existingItem.style.opacity = '0';
                    existingItem.style.transform = 'translateY(-20px)';
                    
                    setTimeout(() => {
                        if (existingItem.parentNode) {
                            existingItem.parentNode.removeChild(existingItem);
                        }
                    }, 300);
                }
            }

            addContentItem(content) {
                // Remove "no content" message if it exists
                const noContent = this.contentGrid.querySelector('.no-content');
                if (noContent) {
                    noContent.remove();
                }

                const contentItem = document.createElement('div');
                contentItem.className = 'content-item';
                contentItem.setAttribute('data-input-id', content.inputId);
                
                const timestamp = new Date(content.generateAt).toLocaleString();
                const hasHaiku = content.haiku && content.haiku.line1;
                const hasImage = content.image && content.image.url;
                
                let contentType = '';
                if (hasHaiku && hasImage) {
                    contentType = 'Haiku + Image';
                } else if (hasHaiku) {
                    contentType = 'Haiku';
                } else if (hasImage) {
                    contentType = 'Image';
                }

                contentItem.innerHTML = `
                    <div class="content-meta">
                        <span class="content-timestamp">${timestamp}</span>
                        <span class="content-type">${contentType}</span>
                    </div>
                    
                    ${hasHaiku ? `
                        <div class="haiku">
                            <div class="haiku-line">${this.escapeHtml(content.haiku.line1)}</div>
                            <div class="haiku-line">${this.escapeHtml(content.haiku.line2)}</div>
                            <div class="haiku-line">${this.escapeHtml(content.haiku.line3)}</div>
                        </div>
                    ` : ''}
                    
                    ${hasImage ? `
                        <div class="image-container">
                            <img src="${this.escapeHtml(content.image.url)}" alt="Generated image" class="generated-image" />
                        </div>
                    ` : ''}

                    <div class="content-prompt">
                        <strong>Prompt:</strong> ${this.escapeHtml(content.prompt)}
                    </div>
                `;

                // Add new content at the beginning
                this.contentGrid.insertBefore(contentItem, this.contentGrid.firstChild);
                
                // Add entrance animation
                contentItem.style.opacity = '0';
                contentItem.style.transform = 'translateY(20px)';
                
                setTimeout(() => {
                    contentItem.style.transition = 'opacity 0.5s, transform 0.5s';
                    contentItem.style.opacity = '1';
                    contentItem.style.transform = 'translateY(0)';
                }, 100);
            }

            initializeForm() {
                this.inputForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await this.submitInput();
                });
            }

            async submitInput() {
                const inputText = this.textInput.value.trim();
                if (!inputText) return;

                this.submitBtn.disabled = true;
                this.submitBtn.innerHTML = '<span class="loading"></span> Submitting...';
                this.hideStatus();

                try {
                    const response = await fetch('http://localhost:9000/inputs', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ input: inputText })
                    });

                    if (response.ok) {
                        this.textInput.value = '';
                        this.showStatus('Input submitted successfully!', 'success');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error submitting input:', error);
                    this.showStatus(`Error submitting input: ${error.message}`, 'error');
                } finally {
                    this.submitBtn.disabled = false;
                    this.submitBtn.innerHTML = 'Submit Input';
                }
            }

            showStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
                
                if (type === 'success') {
                    setTimeout(() => this.hideStatus(), 3000);
                }
            }

            hideStatus() {
                this.status.style.display = 'none';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            destroy() {
                if (this.contentEventSource) {
                    this.contentEventSource.close();
                }
                if (this.collectedEventSource) {
                    this.collectedEventSource.close();
                }
            }
        }

        // Initialize the application
        let qrCodeManager;
        let contentGenerator;
        let inputsManager;
        
        document.addEventListener('DOMContentLoaded', () => {
            qrCodeManager = new QrCodeManager();
            contentGenerator = new ContentGenerator();
            inputsManager = new InputsManager();
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (qrCodeManager) {
                qrCodeManager.destroy();
            }
            if (contentGenerator) {
                contentGenerator.destroy();
            }
            if (inputsManager) {
                inputsManager.destroy();
            }
        });
    </script>
</body>
</html>